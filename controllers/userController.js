const { database } = require("../config/firebase-config");

const { ref, set, get } = require("firebase/database");
const jwt = require("jsonwebtoken");
const fs = require("fs");
const path = require("path");
const { v4: uuidv4 } = require("uuid");
require("dotenv").config();

const bcrypt = require("bcrypt"); // Assuming bcrypt is used for password hashing

// Register User
const registerUser = async (req, res) => {
  const {
    name, // Added name
    username,
    password,
    confirmPassword,
    PhoneNumber,
    teacherPhoneNumber,
    whatsappNumber,
    standard,
    schoolName,
    country,
    state,
    city,
  } = req.body;

  // Validate required fields
  if (!name || !username || !password || !PhoneNumber) {
    return res.status(400).json({
      message: "Name, username, password, and phone number are required",
    });
  }

  // Validate password and confirmPassword match
  if (password !== confirmPassword) {
    return res.status(400).json({
      message: "Password and confirm password do not match",
    });
  }

  try {
    // Hash the password before saving
    const hashedPassword = await bcrypt.hash(password, 10); // Hash with salt rounds

    // Generate a unique ID for the user
    const uid = uuidv4();

    // Save user details to the Realtime Database, storing the hashed password
    const userRef = ref(database, `gio-students/${uid}`);
    try {
      await set(userRef, {
        uid, // Save the UID
        name, // Save the name
        username, // Storing the username
        password: hashedPassword, // Storing the hashed password
        PhoneNumber,
        teacherPhoneNumber,
        whatsappNumber,
        standard,
        schoolName,
        country,
        state,
        city,
        paymentStatus: "unpaid",
        testCompleted: false,
        ranks: {},
        createdAt: new Date().toISOString(),
      });
      console.log("User details successfully written to the database.");
    } catch (dbError) {
      console.error("Error writing user details to the database:", dbError);
      return res.status(500).json({
        message: "Failed to save user details to the database.",
        error: dbError.message,
      });
    }

    // Generate JWT token for the user after registration
    const token = jwt.sign(
      { uid, username, name }, // Include UID, username, and name in the JWT payload
      process.env.JWT_SECRET_KEY, // Secret key for signing the token
      { expiresIn: "1d" } // Expiration time for the token (1 day)
    );

    res.status(201).json({
      message: "User registered successfully",
      uid, // Include UID in the response
      username, // Include username in the response
      name, // Include name in the response
      token, // Send the JWT token to the frontend
    });
  } catch (error) {
    console.error("Error registering user:", error);
    res.status(500).json({
      message: "Failed to register user",
      error: error.message,
    });
  }
};

// Login User
const loginUser = async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password) {
    return res.status(400).json({
      message: "Username and password are required",
    });
  }

  try {
    // Look for the user by username in the database
    const userRef = ref(database, "gio-students");
    const snapshot = await get(userRef);

    let user = null;
    snapshot.forEach((childSnapshot) => {
      if (childSnapshot.val().username === username) {
        user = childSnapshot.val(); // Found the user by username
      }
    });

    if (!user) {
      return res.status(401).json({
        message: "Invalid username or password",
      });
    }

    // Compare the entered password with the stored hashed password
    const isPasswordCorrect = await bcrypt.compare(password, user.password);
    if (!isPasswordCorrect) {
      return res.status(401).json({
        message: "Invalid username or password",
      });
    }

    // Generate JWT token for the user
    const token = jwt.sign(
      { uid: user.uid, username: user.username },
      process.env.JWT_SECRET_KEY,
      { expiresIn: "1d" }
    );

    res.status(200).json({
      message: "Login successful",
      username: user.username,
      token,
    });
  } catch (error) {
    console.error("Error logging in user:", error);
    res.status(500).json({
      message: "Failed to log in user",
      error: error.message,
    });
  }
};

// Get User Profile
const getUserProfile = async (req, res) => {
  const user = req.user; // Extract user information from middleware (e.g., authentication middleware)
  const username = user?.username; // Ensure username exists

  if (!username) {
    return res.status(400).json({
      message: "Username is required for authentication.",
    });
  }

  try {
    // Fetch the database reference
    const userRef = ref(database, "gio-students");
    const snapshot = await get(userRef);

    if (!snapshot.exists()) {
      return res.status(404).json({
        message: "No users found in the database.",
      });
    }

    // Find the user profile based on the username
    const userProfile = Object.values(snapshot.val()).find(
      (userData) => userData.username === username
    );

    if (!userProfile) {
      return res.status(404).json({
        message: "User not found in the database.",
      });
    }

    res.status(200).json({
      message: "User profile fetched successfully.",
      user: userProfile,
    });
  } catch (error) {
    console.error("Error fetching user profile:", error);
    res.status(500).json({
      message: "Failed to fetch user profile.",
      error: error.message,
    });
  }
};

const updatePaymentStatus = async (req, res) => {
  const { paymentStatus } = req.body;
  const user = req.user;

  if (!user) {
    return res.status(400).json({ message: "User data not found." });
  }

  try {
    const userRef = ref(database, `gio-students/${user.uid}`);
    const snapshot = await get(userRef);

    if (!snapshot.exists()) {
      return res.status(400).json({ message: "User not found in the database." });
    }

    const userData = snapshot.val();

    const updates = {
      ...userData,
      paymentStatus,
    };

    // If paymentStatus indicates quiz completion or a new cycle, reset testCompleted
    if (paymentStatus === "quiz_attempted") {
      updates.testCompleted = true; // Mark as completed
    } else if (paymentStatus === "unpaid") {
      updates.testCompleted = false; // Reset for the next attempt
    }

    await set(userRef, updates);

    res.status(200).json({ message: "Payment status and test state updated successfully." });
  } catch (error) {
    console.error("Error updating payment status:", error);
    res.status(500).json({ message: "Failed to update payment status." });
  }
};






// Load Mock Ranks JSON
let globalMockRanksData, countryMockRanksData, stateMockRanksData;

try {
  globalMockRanksData = JSON.parse(
    fs.readFileSync(
      path.join(__dirname, "../public/mockranks/globalrange.json"),
      "utf8"
    )
  );
  countryMockRanksData = JSON.parse(
    fs.readFileSync(
      path.join(__dirname, "../public/mockranks/countryrange.json"),
      "utf8"
    )
  );
  stateMockRanksData = JSON.parse(
    fs.readFileSync(
      path.join(__dirname, "../public/mockranks/staterange.json"),
      "utf8"
    )
  );
} catch (error) {
  console.error("Error loading mock ranks JSON:", error.message);
  process.exit(1);
}

// Load JSON files for live rank data
let globalRanksData, countryRanksData, stateRanksData;

try {
  globalRanksData = JSON.parse(
    fs.readFileSync(
      path.join(__dirname, "../public/liveranks/globalrange.json"),
      "utf8"
    )
  );
} catch (error) {
  console.error("Error loading globalrange.json:", error.message);
  process.exit(1);
}

try {
  countryRanksData = JSON.parse(
    fs.readFileSync(
      path.join(__dirname, "../public/liveranks/countryrange.json"),
      "utf8"
    )
  );
} catch (error) {
  console.error("Error loading countryrange.json:", error.message);
  process.exit(1);
}

try {
  stateRanksData = JSON.parse(
    fs.readFileSync(
      path.join(__dirname, "../public/liveranks/staterange.json"),
      "utf8"
    )
  );
} catch (error) {
  console.error("Error loading staterange.json:", error.message);
  process.exit(1);
}
// Helper function to calculate rank and category
const getRankAndCategory = (score, jsonData, maxScore) => {
  score = Number(score); // Ensure score is a number

  // If the score is the maximum possible score, assign rank 1
  if (score === maxScore) {
    return { rank: 1, category: "Gold" };
  }

  // Find the matching score entry in the JSON
  const entry = jsonData.find((item) => item.score === score);

  if (!entry) {
    return { rank: "Unranked", category: "Unranked" }; // No matching entry
  }

  const [start, end] = entry.rankRange.split(" to ").map(Number);
  const randomRank = Math.floor(Math.random() * (end - start + 1)) + start;

  return { rank: randomRank, category: entry.category };
};

// Save Quiz Marks
const saveQuizMarks = async (req, res) => {
  const { uid } = req.user; // Assuming `uid` is part of the authenticated user object
  const { score, total, type } = req.body;

  if (!uid) {
    return res.status(400).json({
      message: "User UID is required.",
    });
  }

  if (score === undefined || total === undefined || !type) {
    return res.status(400).json({
      message: "Score, total, and type are required.",
    });
  }

  try {
    // Convert score and total to numbers
    const scoreNum = Number(score);
    const totalNum = Number(total);

    // Sanitize testId
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const testId = `test-${timestamp}`;

    // Reference to the user's marks
    const marksRef = ref(
      database,
      `gio-students/${uid}/marks/${type}/${testId}`
    );

    // Save the new test marks
    await set(marksRef, { score: scoreNum, total: totalNum, timestamp });

    // Update Rankings
    const maxScore = type === "mock" ? 100 : 400; // Adjust maxScore as needed
    await updateUserRankings(uid, scoreNum, type, maxScore);

    // Fetch rankings after saving and updating them
    const rankingsRef = ref(database, `gio-students/${uid}/ranks/${type}`);
    const snapshot = await get(rankingsRef);

    if (!snapshot.exists()) {
      console.log("Rankings not found for type:", type); // Log to debug
      return res.status(200).json({
        message: "No rankings available yet.",
        rankings: {
          global: { rank: "Unranked", category: "Unranked" },
          country: { rank: "Unranked", category: "Unranked" },
          state: { rank: "Unranked", category: "Unranked" },
        },
      });
    }

    const userRankings = snapshot.val();

    // Check if this is a live test with a total of 400 marks
    if (type === "live" && totalNum === 400) {
      // Generate a 4-digit random certificate code
      const certificateCode = `GIO-GQC-${Math.floor(
        1000 + Math.random() * 9000
      )}`;

      // Update the user's certificate code, ensuring only the latest one is saved
      await set(
        ref(database, `gio-students/${uid}/certificateCodes`),
        [certificateCode] // Overwrite with only the latest certificate code
      );

      return res.status(200).json({
        message:
          "Live test marks saved, rankings updated, and certificate code generated.",
        rankings: userRankings,
        certificateCode, // Return the newly generated certificate code
      });
    } else {
      return res.status(200).json({
        message: `${
          type.charAt(0).toUpperCase() + type.slice(1)
        } test marks saved and rankings updated successfully.`,
        rankings: userRankings, // Return the rankings as part of the response
      });
    }
  } catch (error) {
    console.error("Error saving marks:", error.message);
    res.status(500).json({
      message: "Failed to save test marks.",
      error: error.message,
    });
  }
};

// Update User Rankings
const updateUserRankings = async (uid, score, type, maxScore) => {
  let globalData, countryData, stateData;

  // Select ranking JSON based on type
  if (type === "mock") {
    globalData = globalMockRanksData;
    countryData = countryMockRanksData;
    stateData = stateMockRanksData;
  } else if (type === "live") {
    globalData = globalRanksData;
    countryData = countryRanksData;
    stateData = stateRanksData;
  } else {
    throw new Error("Invalid type. Must be 'mock' or 'live'.");
  }

  // Calculate ranks based on score
  const globalRank = getRankAndCategory(score, globalData, maxScore);
  const countryRank = getRankAndCategory(score, countryData, maxScore);
  const stateRank = getRankAndCategory(score, stateData, maxScore);

  // Save rankings to the appropriate node
  const rankingsRef = ref(database, `gio-students/${uid}/ranks/${type}`);
  await set(rankingsRef, {
    global: globalRank,
    country: countryRank,
    state: stateRank,
  });

  console.log(
    `${
      type.charAt(0).toUpperCase() + type.slice(1)
    } rankings updated successfully for user:`,
    uid
  );
};

// Get User Rankings
const getUserRankings = async (req, res) => {
  const { uid } = req.user; // Assuming `uid` is part of the authenticated user object
  const { type } = req.query;

  if (!uid) {
    return res.status(400).json({
      message: "User UID is required.",
    });
  }

  if (!type) {
    return res.status(400).json({
      message: "Query parameter 'type' is required.",
    });
  }

  try {
    const rankingsRef = ref(database, `gio-students/${uid}/ranks/${type}`);
    const snapshot = await get(rankingsRef);
    if (!snapshot.exists()) {
      console.log("Rankings not found for type:", type); // Log to debug
      return res.status(200).json({
        message: "No rankings available yet.",
        rankings: {
          global: { rank: "Unranked", category: "Unranked" },
          country: { rank: "Unranked", category: "Unranked" },
          state: { rank: "Unranked", category: "Unranked" },
        },
      });
    }

    const userRankings = snapshot.val();
    res.status(200).json({
      message: "Rankings fetched successfully.",
      rankings: userRankings,
    });
  } catch (error) {
    console.error("Error fetching rankings:", error.message);
    res.status(500).json({
      message: "Failed to fetch rankings.",
      error: error.message,
    });
  }
};

// Get Test Counts
const getTestCounts = async (req, res) => {
  try {
    const { uid } = req.user; // Assume authentication middleware attaches `req.user`

    if (!uid) {
      return res.status(400).json({ message: "User UID is required." });
    }

    // Reference to the user's marks in Firebase
    const marksRef = ref(database, `gio-students/${uid}/marks`);
    const snapshot = await get(marksRef);

    if (!snapshot.exists()) {
      return res.status(200).json({
        message: "No test data available.",
        mock: 0,
        live: 0,
      });
    }

    const marks = snapshot.val();

    // Count mock and live tests
    const mockCount = marks.mock ? Object.keys(marks.mock).length : 0;
    const liveCount = marks.live ? Object.keys(marks.live).length : 0;

    res.status(200).json({
      message: "Test counts fetched successfully.",
      mock: mockCount,
      live: liveCount,
    });
  } catch (error) {
    console.error("Error fetching test counts:", error.message);
    res.status(500).json({
      message: "Failed to fetch test counts.",
      error: error.message,
    });
  }
};
const getAllStudentsTestCounts = async (req, res) => {
  try {
    const { uid } = req.user; // The authenticated school user UID

    if (!uid) {
      return res.status(400).json({ message: "User UID is required." });
    }

    // Fetch the school name from the user's profile (this assumes you have the school in the user's data)
    const schoolName = req.user.schoolName; // Assuming `schoolName` is available in `req.user`

    // Reference to all students in the school
    const studentsRef = ref(database, `gio-students`);
    const snapshot = await get(studentsRef);

    if (!snapshot.exists()) {
      return res.status(200).json({
        message: "No students found for the school.",
        mock: 0,
        live: 0,
      });
    }

    const students = snapshot.val();

    let mockCount = 0;
    let liveCount = 0;

    // Loop through all students to count mock and live tests
    Object.values(students).forEach((student) => {
      if (student.marks && student.marks.mock) {
        mockCount += Object.keys(student.marks.mock).length;
      }
      if (student.marks && student.marks.live) {
        liveCount += Object.keys(student.marks.live).length;
      }
    });

    res.status(200).json({
      message: "Test counts fetched successfully.",
      mock: mockCount,
      live: liveCount,
    });
  } catch (error) {
    console.error("Error fetching all students' test counts:", error.message);
    res.status(500).json({
      message: "Failed to fetch test counts.",
      error: error.message,
    });
  }
};

// const verifyCertificateCode = async (req, res) => {
//   const { certificateCode } = req.body;

//   if (!certificateCode) {
//     return res.status(400).json({
//       message: "Certificate code is required",
//     });
//   }

//   try {
//     // Search for the certificate code in the database
//     const certificateRef = ref(database, `gio-certificates/${certificateCode}`);
//     const snapshot = await get(certificateRef);

//     if (!snapshot.exists()) {
//       return res.status(404).json({
//         message: "Invalid certificate code",
//       });
//     }

//     const certificateData = snapshot.val(); // Certificate data retrieved from the database

//     // Proceed to generate the certificate PDF (You can use a library like PDFKit or any other for PDF generation)
//     const pdfPath = path.join(__dirname, 'certificates', `${certificateData.certificateCode}.pdf`);
//     generatePdf(certificateData, pdfPath);

//     // Send the PDF to the user (For now, we just send the file path, you can send the file as a response in production)
//     res.status(200).json({
//       message: "Certificate generated successfully",
//       certificatePdfPath: pdfPath, // This can be the path or URL for the PDF
//       type: certificateData.type, // Send the certificate type (GQC)
//     });
//   } catch (error) {
//     console.error("Error verifying certificate code:", error);
//     res.status(500).json({
//       message: "Failed to verify certificate code",
//       error: error.message,
//     });
//   }
// };

module.exports = {
  registerUser,
  loginUser,
  getUserProfile,
  saveQuizMarks,
  updatePaymentStatus,
  getUserRankings,
  getTestCounts,
  getAllStudentsTestCounts,
  // verifyCertificateCode,

};
